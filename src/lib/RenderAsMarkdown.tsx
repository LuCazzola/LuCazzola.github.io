import React from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";
import rehypeKatex from "rehype-katex";
// KaTeX CSS must be loaded so the MathML/annotation parts generated by rehype-katex are hidden
import "katex/dist/katex.min.css";
// rehype-raw may not have types bundled in this workspace; ignore TS here and treat as any
// @ts-ignore
import rehypeRaw from "rehype-raw";
import MediaCarousel from "@/components/MediaCarousel";
import { asset } from "@/lib/asset";

// Pseudocode CDN resources (used on the old site)
const PSEUDOCODE_CSS = "https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css";
const PSEUDOCODE_JS = "https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js";

type MediaItem =
  | { type: "image"; src: string; caption?: string; alt?: string; poster?: string }
  | { type: "gif"; src: string; caption?: string; alt?: string }
  | { type: "video"; src: string; poster?: string; caption?: string }
  | { type: "embed"; src: string; caption?: string };

interface RenderOptions {
  // whether to use math plugins
  math?: boolean;
}

// Parse token lists like "1-3,5 7" into numeric indices (0-based)
// parseIndices now returns an array of either numeric indices (0-based) or the string 'placeholder'
function parseIndices(raw: string): Array<number | "placeholder"> {
  if (!raw) return [];
  // accept commas, spaces, dashes as separators; also support ranges like 1-3
  // allow the placeholder character '?' alongside digits
  const tokens = raw.split(/[,\s]+/).filter(Boolean);
  const out: Array<number | "placeholder"> = [];
  for (const t of tokens) {
    if (t.includes("-")) {
      const parts = t.split("-").map((s) => s.trim()).filter(Boolean);
      // treat a two-part token where both parts are numeric as a range (e.g. "1-3")
      if (parts.length === 2) {
        const a = parts[0] === "?" ? null : parseInt(parts[0], 10);
        const b = parts[1] === "?" ? null : parseInt(parts[1], 10);
        if (a !== null && b !== null && !Number.isNaN(a) && !Number.isNaN(b)) {
          const start = Math.min(a, b);
          const end = Math.max(a, b);
          for (let k = start; k <= end; k++) out.push(Math.max(0, k - 1));
          continue;
        }
        // otherwise fallthrough to parsing each part individually (preserve placeholders)
      }
      for (const p of parts) {
        if (p === "?") {
          out.push("placeholder");
        } else {
          const n = parseInt(p, 10);
          if (!Number.isNaN(n)) out.push(Math.max(0, n - 1));
        }
      }
    } else {
      if (t === "?") {
        out.push("placeholder");
      } else {
        const n = parseInt(t, 10);
        if (!Number.isNaN(n)) out.push(Math.max(0, n - 1));
      }
    }
  }
  return out;
}

export default function RenderAsMarkdown(content: string, media?: MediaItem[], options?: RenderOptions): React.ReactNode {
  if (!content) return null;

  const parts: Array<
    | { kind: "text"; text: string }
    | { kind: "media"; indices: Array<number | "placeholder">; scale?: number }
    | { kind: "placeholder" }
    | { kind: "space"; size: string }
  > = [];
  // support:
  // [MEDIA:1-2-3] -> explicit list/ranges
  // [MEDIA:1-2-3:0.8] -> explicit list + scale (0.0-1.0) controlling inner media width
  // [MEDIA...] -> placeholder shorthand (renders the local placeholder)
  // allow '?' inside the MEDIA list to indicate a placeholder slot, e.g. [MEDIA:1-?-3]
  const tokenRegex = /\[MEDIA:([0-9?\-\s,]+)(?::([0-9.]+))?\]|\[MEDIA\.\.\.\]|\[SPACING:(small|medium|large|xlarge)\]/gi;
  let lastIndex = 0;
  let match: RegExpExecArray | null;
  while ((match = tokenRegex.exec(content)) !== null) {
    if (match.index > lastIndex) {
      parts.push({ kind: "text", text: content.slice(lastIndex, match.index) });
    }
    // match[0] contains the full matched string. We support three forms:
    // - [MEDIA:...] where match[1] holds the numeric token list and match[2] optional scale
    // - [MEDIA...] literal placeholder (no capture groups)
    // - [SPACING:...] where match[3] holds the size
    if (match[1] !== undefined) {
      const inds = parseIndices(match[1]);
      const scale = match[2] ? parseFloat(match[2]) : undefined;
      parts.push({ kind: "media", indices: inds, scale });
    } else if (match[0] === "[MEDIA...]") {
      // placeholder shorthand -> render a dedicated placeholder element
      parts.push({ kind: "placeholder" });
    } else if (match[3]) {
      parts.push({ kind: "space", size: match[3] });
    }
    lastIndex = tokenRegex.lastIndex;
  }
  if (lastIndex < content.length) parts.push({ kind: "text", text: content.slice(lastIndex) });

  // render helper for a single media item
  const renderSingle = (m?: MediaItem, key?: React.Key) => {
    if (!m) return <div key={key} className="text-sm text-muted-foreground">Missing media</div>;
    const resolve = (s: string) => {
      if (!s) return s;
      if (s.startsWith("http") || s.startsWith("data:")) return s;
      return s;
    };
      // explicit gif type or image with .gif extension — render as an image so animated GIFs display
      if (m.type === "gif" || (m.type === "image" && /\.gif($|\?)/i.test(String(m.src)))) {
        return (
          <figure key={key} className="w-full">
            <img src={resolve(String(m.src))} alt={(m as any).alt ?? "media"} loading="lazy" className="w-full rounded-lg object-cover" />
            {m.caption && <figcaption className="text-sm text-muted-foreground mt-2">{m.caption}</figcaption>}
          </figure>
        );
      }
      if (m.type === "image") {
      return (
        <figure key={key} className="w-full">
          <img src={resolve(String(m.src))} alt={m.alt ?? "media"} loading="lazy" className="w-full rounded-lg object-cover" />
          {m.caption && <figcaption className="text-sm text-muted-foreground mt-2">{m.caption}</figcaption>}
        </figure>
      );
    }
    if (m.type === "video") {
      return (
        <figure key={key} className="w-full">
          <video controls poster={resolve(String(m.poster ?? ""))} className="w-full rounded-lg">
            <source src={resolve(String(m.src))} />
          </video>
          {m.caption && <figcaption className="text-sm text-muted-foreground mt-2">{m.caption}</figcaption>}
        </figure>
      );
    }
    // embed
    return (
      <div key={key} className="aspect-video w-full rounded-lg overflow-hidden">
        <iframe src={resolve(String(m.src))} title={m.caption ?? "embed"} allowFullScreen className="w-full h-full" />
        {m.caption && <div className="text-sm text-muted-foreground mt-2">{m.caption}</div>}
      </div>
    );
  };

  // pseudocode support removed per user request

  const mapSize: Record<string, string> = { small: "my-4", medium: "my-8", large: "my-12", xlarge: "my-16" };

  return (
    <div className="space-y-6">
      {parts.map((p, i) => {
        if (p.kind === "text") {
          const block = p.text.trim();
          if (!block) return null;
          return (
            <div key={i} className="markdown-body prose prose-lg max-w-none">
              <ReactMarkdown
                remarkPlugins={[remarkGfm, ...(options?.math ? [remarkMath] : [])]}
                // when using rehype-katex it may emit raw HTML nodes; include rehypeRaw so they are parsed
                rehypePlugins={[...(options?.math ? [(rehypeKatex as any), (rehypeRaw as any)] : [])]}
              >
                {block}
              </ReactMarkdown>
            </div>
          );
        }
        if (p.kind === "space") {
          const cls = mapSize[p.size] ?? "my-8";
          return <div key={i} className={cls} />;
        }
        if (p.kind === "media") {
          // media part
          const items = (p.indices || []).map((entry) => {
            if (entry === "placeholder") {
              return { type: "image", src: asset("/media/placeholder.svg"), caption: "Placeholder" } as MediaItem;
            }
            return media?.[entry as number];
          }).filter(Boolean) as MediaItem[];
          if (items.length === 0) {
            return (
              <div key={i} style={{ marginTop: 12, color: "#666" }}>
                <em>No media available</em>
              </div>
            );
          }
          const scale = typeof p.scale === "number" && !Number.isNaN(p.scale) ? Math.max(0.05, Math.min(1, p.scale)) : 1;
          const innerMax = Math.round(1200 * scale);
          if (items.length === 1) {
            return (
              // full-bleed white background that spans the viewport width
              <div
                key={i}
                style={{
                  marginTop: 12,
                  background: "#fff",
                  padding: 12,
                  borderRadius: 8,
                  width: "100vw",
                  position: "relative",
                  left: "50%",
                  right: "50%",
                  marginLeft: "-50vw",
                  marginRight: "-50vw",
                }}
              >
                <div style={{ maxWidth: innerMax, margin: "0 auto" }}>{renderSingle(items[0], i)}</div>
              </div>
            );
          }
          // multiple -> carousel (also full-bleed background, inner max width scaled)
          // MediaCarousel expects items with type 'image'|'video'|'embed' — map any 'gif' entries to 'image'
          const carouselItems = items.map((it) => {
            if ((it as any).type === "gif") {
              return { type: "image", src: (it as any).src, caption: (it as any).caption };
            }
            return it as any;
          });

          return (
            <div
              key={i}
              style={{
                marginTop: 16,
                background: "#fff",
                padding: 12,
                borderRadius: 8,
                width: "100vw",
                position: "relative",
                left: "50%",
                right: "50%",
                marginLeft: "-50vw",
                marginRight: "-50vw",
              }}
            >
              <div style={{ maxWidth: innerMax, margin: "0 auto" }}>
                <MediaCarousel items={carouselItems} />
              </div>
            </div>
          );
        }
        if (p.kind === "placeholder") {
          // Render a controlled local placeholder image rather than mapping to media[0].
          return (
            <div
              key={i}
              style={{
                marginTop: 12,
                background: "#fff",
                padding: 12,
                borderRadius: 8,
                width: "100vw",
                position: "relative",
                left: "50%",
                right: "50%",
                marginLeft: "-50vw",
                marginRight: "-50vw",
              }}
            >
              <div style={{ maxWidth: 1200, margin: "0 auto" }}>
                <figure className="w-full">
                  <img src={asset("/media/placeholder.svg")} alt="placeholder" loading="lazy" className="w-full rounded-lg object-cover" />
                  <figcaption className="text-sm text-muted-foreground mt-2">Placeholder media</figcaption>
                </figure>
              </div>
            </div>
          );
        }
      })}
    </div>
  );
}
